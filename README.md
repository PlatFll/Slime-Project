# Slime Jump Project

<p align="center">
<img width="600" alt="SlimeJump Logo" src="https://github.com/user-attachments/assets/00f8e7dc-e5e2-4e56-a7f5-65f6f9841cf1" />
</p>

A small game I was working on , It's a game where the player is a slime jumping and climbing up as many platforms/floors as possible while avoiding various hazards like enemies and traps trying to achieve as high a score as possible.
The idea was to be a replayable endless-type game where the player would try over and over to go as far as possible and reach the highest score possible , The platforms would be randomly generated by the platform generator I made where I'd insert multiple pre-fabs of hand-made platforms and they all get randomly stacked on top of one another and deleting previous floors at a certain distance below the player to save up space.

A short gameplay video:

<div style="display:flex; justify-content:center;">
<video src="https://github.com/user-attachments/assets/ba2c3255-656e-46a7-b6fa-3d3fff6e0c43" autoplay loop muted></video>
</div>

<H2>Game Concept</H2>
Inspired by classic pixel platformers and old-school simplistic graphics this project explored physics-based slime movement and procedural platform generation to create replayablity and simple fun, think of games such as Jetpack Joyride / Subway Surfers / etc.

<h2>Core Systems</h2>

<h4>Player Movement</h4>

<video src="https://github.com/user-attachments/assets/40b3e0fc-fb79-4555-bfa5-53f504c3ddb8" autoplay loop muted></video>



<p>The player moves by dragging their finger accross the touch screen of their mobile device , kind of like sling shotting yourself across short distances to mimic the fantasy-like movement of a slime creature.
Movement here is entirely driven by vector math and the 2D physics systems of the engine , When the player drags the screen the game records a start point and continuously updates a trajectory line between that point and the current cursor position.</p>
<p></p>On release, the difference between the two points basically translates into the jump direction and power of said jump.</p>
<p></p>This vector is applied as an impulse to the slime's Rigidbody2D, launching it across the scene. Then I tried using Vector2.Lerp to simulate friction and air resistance so the slime wouldn't fly too high or too far to the right or left, you can also tap mid-air to force the slime to stomp down to the ground when needed to land earlier than the trajectory would've sent you (Had some hard platforming planned for higher levels so I implemented this early.. Plus it feels also better to have it than not to)</p>
<p></p>Animation controller is also used to update the states of the slime between "Still", "Jump" and "Idle".</p>

A small snippet of the code used :

```csharp
if(Input.GetMouseButtonDown(0))
{
    startPoint = cam.ScreenToWorldPoint(Input.mousePosition);
    startPoint.z = 15;
}

if(Input.GetMouseButton(0))
{
    Vector3 currentPoint = cam.ScreenToWorldPoint(Input.mousePosition);
    currentPoint.z = 5;
    tl.RenderLine(startPoint, currentPoint);
}

if(Input.GetMouseButtonUp(0))
{
    tl.EndLine();
    endPoint = cam.ScreenToWorldPoint(Input.mousePosition);
    endPoint.z = 15;

    force = CalculatePowerVectorV2(startPoint, endPoint);
    rb.AddForce(force * power, ForceMode2D.Impulse);
    anim.SetTrigger("Jump");
}
```
<h4>Enemy Movement</h4>

<video src="https://github.com/user-attachments/assets/8b377402-36c1-4234-81a6-86df64c47fdc" autoplay loop muted></video>

<p>The enemy patrol system simply has two preset points the enemy would be moving to back and forth which is very common in platformer games.</p>
<p>During gameplay the enemy would move until it reaches the predetermined edge and then activate an idle animation before it moves again , giving the illusion of awareness and timing in the enemy's behavior.</p>
<p>I also made an animation and some code for the enemy being able to swing it's sword if the player was close enough. </p>

A small snippet of the code for enemy movement :

```csharp

if(movingLeft)
        {   
            if(enemy.position.x >= leftEdge.position.x)
                MoveInDirection(-1);
            else
            {
                DirectionChange();
            }
        }
        else
        {   
            if(enemy.position.x <= rightEdge.position.x)
                MoveInDirection(1);
            else
            {
                DirectionChange();
            }

private void DirectionChange()
    {
        anim.SetBool("Moving", false);

        idleTimer += Time.deltaTime;

        if(idleTimer > idleDuration)
            movingLeft = !movingLeft;
    }

private void MoveInDirection(int direction)
    {
        idleTimer = 0;
        anim.SetBool("Moving", true);

        //Make enemy face direction
        enemy.localScale = new Vector3(Mathf.Abs(initScale.x) * direction, initScale.y, initScale.z);
        //Move in that direction
        enemy.position = new Vector3(enemy.position.x + Time.deltaTime * direction * speed,
        enemy.position.y, enemy.position.z);
    }
```

<h4>Platform Generator</h4>

<img width="405" alt="SlimeJumpPlatformGenerator" src="https://github.com/user-attachments/assets/bcef704f-8333-4613-9910-308fdb1e65c8" />

<p>The platform generator is the main system of the whole game , It's responsible for creating the endless platforms illusion.</p>
<p>It dynamically spawns new platforms above the player levels before the player even reaches them while simultaniously deleting older platforms below the player to optimize performance.</p>
<p>The system takes a list of prefrabs in Unity , those prefabs would be hand-made platform combinations with different enemies / traps / designs. You could add as many as you want and the system would randomly choose between them and spawn them on top of one another with the exact same distance between each platform, This design choice gave me alot of creative freedom to make up platforms of as many different combinations as I could think of.</p>

```csharp

void Update()
{
    // Generate new platforms when player climbs high enough
    if (player.transform.position.y > (lastPlatformY - 100))
    {
        for (int i = 0; i < numPlatforms; i++)
        {
            GeneratePlatform();
            platformCounter++;

            // Clean up every few cycles
            if (platformCounter >= 5)
            {
                platformCounter = 0;
                DestroyPlatformsBelowPlayer();
            }
        }
    }
}

void GeneratePlatform()
{
    GameObject prefab = platformPrefabList[Random.Range(0, platformPrefabList.Count)];
    GameObject platform = Instantiate(prefab);

    float x = Random.Range(-maxX, maxX);
    float y = lastPlatformY + gap;
    platform.transform.position = new Vector3(x, y, 0);

    generatedPlatforms.Add(platform);
    lastPlatformY = y;
}
```

<h4>Damage & HP</h4>

<video src="https://github.com/user-attachments/assets/fda94111-1b8d-48a6-a0c7-7237bd292845" autoplay loop muted></video>

<p>The classic player character starts to flash white and become invulnerable for a second, Player takes damage when the hitbox attached to the player's character comes to contact with an enemy or a trap.</p>

Code snippet for the invulnerability effect :

```csharp

    private IEnumerator Invulnerability()
    {
        Physics2D.IgnoreLayerCollision(7, 8, true);
        for(int i = 0; i < numberOfFlashes; i++)
        {                   
            spriteRend.material = flashMaterial;
            yield return new WaitForSeconds(iFramesDuration / (numberOfFlashes * 2));        
            spriteRend.material = originalMaterial;
            yield return new WaitForSeconds(iFramesDuration / (numberOfFlashes * 2));
        }
        Physics2D.IgnoreLayerCollision(7, 8, false);

    }

```

<video src="https://github.com/user-attachments/assets/78a7ba59-6c26-48ff-8fd0-c411e46244ff" autoplay loop muted></video>

<p>Player loses HP as long as they have any whenn getting hit or taking damage.</p>

```csharp

    public void TakeDamage(float damage)
    {
        currentHealth = Mathf.Clamp(currentHealth - damage, 0, startingHealth);

        if(currentHealth > 0)
        {
            anim.SetTrigger("Hurt");
            //IFrames
            StartCoroutine(Invulnerability());
        }
```
<h4>Lava.</h4>

<p>I wanted to add a mechanic that would make the player keep going and not stop, a time limit obviously wouldn't work in a game like this so what better option than to be chased by rising lava to keep you going up the platforms?</p>

<p>Well... It was supposed to be lava but as I'm not really good at pixel art... Just see for yourself.</p>

<video src="https://github.com/user-attachments/assets/2c9b838c-b552-4993-a1f1-c3f084cd3a76" autoplay loop muted></video>


<p>The lava would always be at a certain distance below the player no matter how fast or how slow the player moves up the platforms , I added this because I wanted to also add power-ups in the future and one of the powerups would be a super jump to skip multiple platforms at once, And if the lava was always going at the same speed it'd never catch up to a fast player or a power-up abuser so I added this mechanic early on.</p>

<h2>Future Plans</h2>

```markdown

- Menu system and the ability to save your score.
- Vastly expand on enemy types and traps
- Vastly expand on platform combination and variation
- Possibility of region changes the higher the player goes?
- Power-ups and Slime evolutions
- Boss encounters that would stop the player in a limited platform space or be chased by a boss that throws attacks from above?
```

<h2>Project Info</h2>

```markdown
- Engine: Unity 2021.3.3f1
- Language: C#
- Art: Custom 32x32 pixel sprites
- Version Control: Git + Github
```

<h2>Final Thoughts / Notes </h2>

<p>This was my first big project in gamedev and I learned a ton about platformer physics, sprite animation (except the block of cheese) , procedural generation and enemy behaviour.</p>
<p>The two biggest challenges were :</p>
    <p>1 - Balancing the smoothness of the movement with precide jumping , I fixed this by tweaking RigidBody2D gravity and drag manually.</p>
    <p>2 - Figuring out how to create the platform generator and then making it work how I envisioned it to.</p>
<p>All in all I had alot of fun working on this project and I learned alot. If you'd like to connect or give me feedback we could do that either here or on LinkedIn:</p>

<p align="center">
  <a href="https://www.linkedin.com/in/ali-dia-0563a5242/" target="_blank">
    <img src="https://img.shields.io/badge/LinkedIn-Connect-blue?logo=linkedin" alt="LinkedIn Badge"/>
  </a>
</p>

<p align="center">
<h2>Thank you for taking the time to check out my project, Have a great day.</h2>
</p>
