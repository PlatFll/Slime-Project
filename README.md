# Slime Jump Project

<p align="center">
<img width="600" alt="SlimeJump Logo" src="https://github.com/user-attachments/assets/00f8e7dc-e5e2-4e56-a7f5-65f6f9841cf1" />
</p>

A small game I was working on , It's a game where the player is a slime jumping and climbing up as many platforms/floors as possible while avoiding various hazards like enemies and traps trying to achieve as high a score as possible.
The idea was to be a replayable endless-type game where the player would try over and over to go as far as possible and reach the highest score possible , The platforms would be randomly generated by the platform generator I made where I'd insert multiple pre-fabs of hand-made platforms and they all get randomly stacked on top of one another and deleting previous floors at a certain distance below the player to save up space.

A short gameplay video:

<div style="display:flex; justify-content:center;">
<video src="https://github.com/user-attachments/assets/ba2c3255-656e-46a7-b6fa-3d3fff6e0c43" autoplay loop muted></video>
</div>

<H3>Game Concept</H3>
Inspired by classic pixel platformers and old-school simplistic graphics this project explored physics-based slime movement and procedural platform generation to create replayablity and simple fun, think of games such as Jetpack Joyride / Subway Surfers / etc.

<H3>Core Systems</H3>

<H5>Player Movement</H5>

<video src="https://github.com/user-attachments/assets/40b3e0fc-fb79-4555-bfa5-53f504c3ddb8" autoplay loop muted></video>



<p>The player moves by dragging their finger accross the touch screen of their mobile device , kind of like sling shotting yourself across short distances to mimic the fantasy-like movement of a slime creature.
Movement here is entirely driven by vector math and the 2D physics systems of the engine , When the player drags the screen the game records a start point and continuously updates a trajectory line between that point and the current cursor position.</p>
<p></p>On release, the difference between the two points basically translates into the jump direction and power of said jump.</p>
<p></p>This vector is applied as an impulse to the slime's Rigidbody2D, launching it across the scene. Then I tried using Vector2.Lerp to simulate friction and air resistance so the slime wouldn't fly too high or too far to the right or left, you can also tap mid-air to force the slime to stomp down to the ground when needed to land earlier than the trajectory would've sent you (Had some hard platforming planned for higher levels so I implemented this early.. Plus it feels also better to have it than not to)</p>
<p></p>Animation controller is also used to update the states of the slime between "Still", "Jump" and "Idle".</p>

A small snippet of the code used :

```csharp
if(Input.GetMouseButtonDown(0))
{
    startPoint = cam.ScreenToWorldPoint(Input.mousePosition);
    startPoint.z = 15;
}

if(Input.GetMouseButton(0))
{
    Vector3 currentPoint = cam.ScreenToWorldPoint(Input.mousePosition);
    currentPoint.z = 5;
    tl.RenderLine(startPoint, currentPoint);
}

if(Input.GetMouseButtonUp(0))
{
    tl.EndLine();
    endPoint = cam.ScreenToWorldPoint(Input.mousePosition);
    endPoint.z = 15;

    force = CalculatePowerVectorV2(startPoint, endPoint);
    rb.AddForce(force * power, ForceMode2D.Impulse);
    anim.SetTrigger("Jump");
}
```
<H5>Enemy Movement</H5>

<video src="https://github.com/user-attachments/assets/8b377402-36c1-4234-81a6-86df64c47fdc" autoplay loop muted></video>

<p>The enemy patrol system simply has two preset points the enemy would be moving to back and forth which is very common in platformer games.</p>
<p>During gameplay the enemy would move until it reaches the predetermined edge and then activate an idle animation before it moves again , giving the illusian of awareness and timing in the enemy's behavior.</p>
<p>I also made an animation and some code for the enemy being able to swing it's sword if the player was close enough. </p>

A small snippet of the code for enemy movement :

```csharp

        if(movingLeft)
        {   
            if(enemy.position.x >= leftEdge.position.x)
                MoveInDirection(-1);
            else
            {
                DirectionChange();
            }
        }
        else
        {   
            if(enemy.position.x <= rightEdge.position.x)
                MoveInDirection(1);
            else
            {
                DirectionChange();
            }

    private void DirectionChange()
    {
        anim.SetBool("Moving", false);

        idleTimer += Time.deltaTime;

        if(idleTimer > idleDuration)
            movingLeft = !movingLeft;
    }

    private void MoveInDirection(int direction)
    {
        idleTimer = 0;
        anim.SetBool("Moving", true);

        //Make enemy face direction
        enemy.localScale = new Vector3(Mathf.Abs(initScale.x) * direction, initScale.y, initScale.z);
        //Move in that direction
        enemy.position = new Vector3(enemy.position.x + Time.deltaTime * direction * speed,
        enemy.position.y, enemy.position.z);
    }
```
